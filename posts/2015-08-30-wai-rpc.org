#+TITLE: RPC на основе WAI
#+TAGS: haskell, webdev
* Введение
Сейчас web-разработка на *Haskell* достаточно проста, даже для новичка. Этому способствует
наличие таких пакетов, как [[http://www.yesodweb.com/][Yasod]] и [[http://snapframework.com/][Snap]]. Но не всегда мощь и полнота охвата необходимы.
Порой от "сервера" требуется столь мало, что не хочется иметь в зависимостях подобных "монстров",
особенно в тех случаях, когда задача /достаточно просто/ решаема и более простыми средствами.

Пусть примером послужит такая задача: требуется реализовать сервис, позволяющий вызывать
на сервере некие функции и получать результат вызова, или, говоря общепринятым языком,
выполнять RPC.

Такую задачу можно решить, используя [[http://hackage.haskell.org/package/Spock][Spock]], [[http://hackage.haskell.org/package/scotty][scotty]] или, скажем, [[http://hackage.haskell.org/package/servant][servant]],
но "мы пойдем другим путем"[[https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25BD%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B5_%25D1%2584%25D1%2580%25D0%25B0%25D0%25B7%25D1%258B][©]]!

Большинство библиотек для web-разработки внутри использует так называемый
*Web Application Interface* ([[http://hackage.haskell.org/package/wai][WAI)]] - обобщенный /протокол общения web-сервера
и web-приложения/. Приложения, реализующие этот протокол, называют
WAI-приложениями и запускают с помощью сервера wai-приложений - [[http://www.stackage.org/package/warp][warp]].

Реализуем же и мы простой сервис на чистом WAI!

* WAI-сервис
** Задача
Реализовать сервис вызова функций типа ~String -> String~. Для примера реализуем
функции ~reverse~, ~upper~ и ~lower~.

API будет следующим:
- ~GET~ на ~/~ возвращает список имен доступных функций (по одному на строку),
- ~GET~ на ~/<function_name>?<argument>~ возвращает результат вызова функции.

** "Hello, World!"
Для начала создадим проект и реализуем сервер-заглушку, отвечающий известной строкой
на любой запрос.

Создаем проект:

#+begin_src shell
  $ stack new wai-rpc simple --resolver lts-3.2
#+end_src

*ВНИМАНИЕ:* предполагается, что у вас установлена утилита [[https://github.com/commercialhaskell/stack][stack]],
также ключ ~--resolver lst-3.2~ означает, что будет использоваться снимок версии 3.2
- именно этот снимок был актуален на момент написания статьи.
(подробнее о снимках можно почитать в документации к stack).

После создания проекта добавляем зависимости ~http-types~, ~wai~ и ~warp~
в ~.cabal~-файл:

#+begin_src shell
  -- ...часть файла опущена...
  executable wai-rpc
    hs-source-dirs:      src
    main-is:             Main.hs
    default-language:    Haskell2010
    build-depends:       base >= 4.7 && < 5,
                         http-types, wai, warp -- <-- добавлено
#+end_src

Затем содержимое файла ~src/Main.hs~ заменяем на:

#+begin_src haskell
  {-# LANGUAGE OverloadedStrings #-}
  module Main where

  import Network.Wai
  import Network.HTTP.Types (status200, hContentType)
  import Network.Wai.Handler.Warp (run)

  application :: Application
  application _ respond = respond $
    responseLBS status200 [(hContentType, "text/plain")] "Hello World"

  main :: IO ()
  main = do
    putStrLn "Serving..."
    run 8000 application
#+end_src

К слову, этот код практически слово-в-слово повторяет [[http://www.yesodweb.com/book/web-application-interface#web-application-interface_hello_world][helloworld]] от авторов
библиотеки WAI ;)

Осталось собрать проект:

#+begin_src shell
  $ stack build
#+end_src

И запустить:

#+begin_src shell
  $ stack exec wai-rpc
  Serving...
#+end_src

Если при запущенном сервере открыть в браузере url [[http://localhost:8000]],
то в браузере отобразится ожидаемое приветствие. Сервер работает!

Теперь стоит разобрать, из чего же состоит наш сервер.

~main~ содержит строку

#+begin_src shell
run 8000 application
#+end_src

Это запуск сервера ~warp~ на порту ~8000~ с единственным WAI-приложением - ~application~.

Приложение ~application~ имеет тип [[http://haddock.stackage.org/lts-3.2/wai-3.0.3.0/Network-Wai.html#t:Application][Application]], который является синонимом для

#+begin_src shell
  type Application = Request
                     -> (Response -> IO ResponseReceived)
                     -> IO ResponseReceived
#+end_src

Здесь первый аргумент, это тип [[http://haddock.stackage.org/lts-3.2/wai-3.0.3.0/Network-Wai.html#t:Request][Request]], описывающий запрос, а второй - "ответчик",
функция, призванная возвращать ответ [[http://haddock.stackage.org/lts-3.2/wai-3.0.3.0/Network-Wai.html#t:Response][Response]] в процессе выполнения некой работы
(монада ~IO~).

В данном случае приложение сразу же отвечает фиксированным сообщением, поэтому
тело приложения - единственный вызов ответчика ~respond~.

Ответ же в данном случае выглядит так:

#+begin_src haskell
  responseLBS status200
                -- :: Network.HTTP.Types.Status
              [(hContentType, "text/plain")]
                -- :: [(Network.HTTP.Types.HeaderName, ByteString)]
              "Hello World!"
                -- :: Lazy ByteString
#+end_src

Всё достаточно привычно: статус, заголовки и тело.

Вот, собственно и всё! Это уже вполне самостоятельный сервер, можно пускать
в production :) И это не шутка - warp испытан и проверен, и, ко всему прочему,
весьма быстр и пригоден для "вывешивания наружу" (т.е. не требует заворачивания
во всякие Nginx).

** Маршрутизация
